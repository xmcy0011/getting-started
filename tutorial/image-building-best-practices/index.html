<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="Getting Started with Docker"><link href=https://xmcy0011.github.io/getting-started-cn/tutorial/image-building-best-practices/ rel=canonical><meta name=author content=Docker><meta name=lang:clipboard.copy content="Copy to clipboard"><meta name=lang:clipboard.copied content="Copied to clipboard"><meta name=lang:search.language content=en><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content="No matching documents"><meta name=lang:search.result.one content="1 matching document"><meta name=lang:search.result.other content="# matching documents"><meta name=lang:search.tokenizer content=[\s\-]+><link rel="shortcut icon" href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.2.3, mkdocs-material-4.6.3"><title>构建镜像最佳实践 - Getting Started</title><link rel=stylesheet href=../../assets/stylesheets/application.adb8469c.css><link rel=stylesheet href=../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content=#2196f3><script src=../../assets/javascripts/modernizr.86422ebf.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../assets/fonts/material-icons.css><link rel=stylesheet href=../../css/styles.css><link rel=stylesheet href=../../css/dark-mode.css></head> <body dir=ltr data-md-color-primary=blue data-md-color-accent=blue> <svg class=md-svg> <defs> <svg xmlns=http://www.w3.org/2000/svg width=416 height=448 viewbox="0 0 416 448" id=__github><path fill=currentColor d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#security-scanning tabindex=0 class=md-skip> Skip to content </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=https://xmcy0011.github.io/getting-started-cn/ title="Getting Started" aria-label="Getting Started" class="md-header-nav__button md-logo"> <img alt=logo src=../../images/docker-labs-logo.svg width=24 height=24> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> Getting Started </span> <span class=md-header-nav__topic> 构建镜像最佳实践 </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--search md-header-nav__button" for=__search></label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input aria-label=search name=query placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=query data-md-state=active> <label class="md-icon md-search__icon" for=__search></label> <button type=reset class="md-icon md-search__icon" data-md-component=reset tabindex=-1> &#xE5CD; </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=result> <div class=md-search-result__meta> Type to start searching </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source> <a href=https://github.com/xmcy0011/getting-started-cn title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> xmcy0011/getting-started-cn </div> </a> </div> </div> </div> </nav> </header> <div class=md-container> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=https://xmcy0011.github.io/getting-started-cn/ title="Getting Started" class="md-nav__button md-logo"> <img alt=logo src=../../images/docker-labs-logo.svg width=48 height=48> </a> Getting Started </label> <div class=md-nav__source> <a href=https://github.com/xmcy0011/getting-started-cn title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> xmcy0011/getting-started-cn </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../ title=开始 class=md-nav__link> 开始 </a> </li> <li class=md-nav__item> <a href=../our-application/ title=示例程序 class=md-nav__link> 示例程序 </a> </li> <li class=md-nav__item> <a href=../updating-our-app/ title=更新镜像 class=md-nav__link> 更新镜像 </a> </li> <li class=md-nav__item> <a href=../sharing-our-app/ title=上传镜像 class=md-nav__link> 上传镜像 </a> </li> <li class=md-nav__item> <a href=../persisting-our-data/ title=持久化DB class=md-nav__link> 持久化DB </a> </li> <li class=md-nav__item> <a href=../using-bind-mounts/ title=绑定挂载 class=md-nav__link> 绑定挂载 </a> </li> <li class=md-nav__item> <a href=../multi-container-apps/ title=多容器应用 class=md-nav__link> 多容器应用 </a> </li> <li class=md-nav__item> <a href=../using-docker-compose/ title="使用Docker Compose" class=md-nav__link> 使用Docker Compose </a> </li> <li class="md-nav__item md-nav__item--active"> <input class="md-toggle md-nav__toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> 构建镜像最佳实践 </label> <a href=./ title=构建镜像最佳实践 class="md-nav__link md-nav__link--active"> 构建镜像最佳实践 </a> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#security-scanning class=md-nav__link> 安全扫描（Security Scanning） </a> </li> <li class=md-nav__item> <a href=#image-layering class=md-nav__link> 镜像分层（Image Layering） </a> </li> <li class=md-nav__item> <a href=#layer-caching class=md-nav__link> 镜像缓存（Layer Caching） </a> </li> <li class=md-nav__item> <a href=#multi-stage-builds class=md-nav__link> 多阶段构建（Multi-Stage Builds） </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#maventomcat class=md-nav__link> Maven/Tomcat 示例 </a> </li> <li class=md-nav__item> <a href=#react class=md-nav__link> React 示例 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 总结 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../what-next/ title=接下来? class=md-nav__link> 接下来? </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#security-scanning class=md-nav__link> 安全扫描（Security Scanning） </a> </li> <li class=md-nav__item> <a href=#image-layering class=md-nav__link> 镜像分层（Image Layering） </a> </li> <li class=md-nav__item> <a href=#layer-caching class=md-nav__link> 镜像缓存（Layer Caching） </a> </li> <li class=md-nav__item> <a href=#multi-stage-builds class=md-nav__link> 多阶段构建（Multi-Stage Builds） </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#maventomcat class=md-nav__link> Maven/Tomcat 示例 </a> </li> <li class=md-nav__item> <a href=#react class=md-nav__link> React 示例 </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#_1 class=md-nav__link> 总结 </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1>构建镜像最佳实践</h1> <h2 id=security-scanning>安全扫描（Security Scanning）<a class=headerlink href=#security-scanning title="Permanent link">&para;</a></h2> <!-- When you have built an image, it is good practice to scan it for security vulnerabilities using the `docker scan` command.
Docker has partnered with [Snyk](http://snyk.io) to provide the vulnerability scanning service. --> <p>构建镜像后，最好使用<code>docker scan</code>命令对其进行安全漏洞扫描。 Docker已与<a href=http://snyk.io>Snyk</a>合作提供漏洞扫描服务。</p> <!-- For example, to scan the `getting-started` image you created earlier in the tutorial, you can just type --> <p>比如，扫描您在教程早期创建的<code>getting-started</code>镜像：</p> <div class=highlight><pre><span></span><code>docker scan getting-started
</code></pre></div> <!-- The scan uses a constantly updated database of vulnerabilities, so the output you see will vary as new
vulnerabilities are discovered, but it might look something like this: --> <p>它的原理是使用一个不断更新的漏洞数据库，因此您看到的输出会随着新的漏洞而变化，可能是这样的：</p> <div class=highlight><pre><span></span><code>✗ Low severity vulnerability found in freetype/freetype
  Description: CVE-2020-15999
  Info: https://snyk.io/vuln/SNYK-ALPINE310-FREETYPE-1019641
  Introduced through: freetype/freetype@2.10.0-r0, gd/libgd@2.2.5-r2
  From: freetype/freetype@2.10.0-r0
  From: gd/libgd@2.2.5-r2 &gt; freetype/freetype@2.10.0-r0
  Fixed in: 2.10.0-r1

✗ Medium severity vulnerability found in libxml2/libxml2
  Description: Out-of-bounds Read
  Info: https://snyk.io/vuln/SNYK-ALPINE310-LIBXML2-674791
  Introduced through: libxml2/libxml2@2.9.9-r3, libxslt/libxslt@1.1.33-r3, nginx-module-xslt/nginx-module-xslt@1.17.9-r1
  From: libxml2/libxml2@2.9.9-r3
  From: libxslt/libxslt@1.1.33-r3 &gt; libxml2/libxml2@2.9.9-r3
  From: nginx-module-xslt/nginx-module-xslt@1.17.9-r1 &gt; libxml2/libxml2@2.9.9-r3
  Fixed in: 2.9.9-r4
</code></pre></div> <!-- The output lists the type of vulnerability, a URL to learn more, and importantly which version of the relevant library
fixes the vulnerability. --> <p>这些输出列出了漏洞的类型、要了解更多信息的URL，以及最重要的是相关库的哪个版本修复了该漏洞。</p> <!-- There are several other options, which you can read about in the [docker scan documentation](https://docs.docker.com/engine/scan/). --> <p>您可以通过阅读这个文档 <a href=https://docs.docker.com/engine/scan/ >docker scan documentation</a> 了解更多信息。</p> <!-- As well as scanning your newly built image on the command line, you can also [configure Docker Hub](https://docs.docker.com/docker-hub/vulnerability-scanning/)
to scan all newly pushed images automatically, and you can then see the results in both Docker Hub and Docker Desktop. --> <p>除了在命令行上扫描新构建的镜像，还可以 <a href=https://docs.docker.com/docker-hub/vulnerability-scanning/ >配置Docker Hub</a> 自动扫描所有新推送的镜像，然后可以在Docker Hub和Docker Desktop中看到结果。</p> <p class=text-center><img alt="Hub vulnerability scanning" src=hvs.png style=width:75%></p> <!-- ## Image Layering --> <h2 id=image-layering>镜像分层（Image Layering）<a class=headerlink href=#image-layering title="Permanent link">&para;</a></h2> <!-- Did you know that you can look at what makes up an image? Using the `docker image history`
command, you can see the command that was used to create each layer within an image. --> <p>您知道吗，您可以查看镜像的组成？使用<code>docker image history</code>命令，可以看到用于在镜像中创建每个层的命令。</p> <!-- 1. Use the `docker image history` command to see the layers in the `getting-started` image you
   created earlier in the tutorial. --> <ol> <li> <p>使用 <code>docker image history</code> 命令查看您在教程早期创建的<code>getting-started</code>镜像： <div class=highlight><pre><span></span><code>docker image <span class=nb>history</span> getting-started
</code></pre></div></p> <p><!-- You should get output that looks something like this (dates/IDs may be different). --> 您应该会得到下面的输出（dates/IDs 可能不一样）：</p> <div class=highlight><pre><span></span><code>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
a78a40cbf866        18 seconds ago      /bin/sh -c #(nop)  CMD [&quot;node&quot; &quot;src/index.j…    0B                  
f1d1808565d6        19 seconds ago      /bin/sh -c yarn install --production            85.4MB              
a2c054d14948        36 seconds ago      /bin/sh -c #(nop) COPY dir:5dc710ad87c789593…   198kB               
9577ae713121        37 seconds ago      /bin/sh -c #(nop) WORKDIR /app                  0B                  
b95baba1cfdb        13 days ago         /bin/sh -c #(nop)  CMD [&quot;node&quot;]                 0B                  
&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENTRYPOINT [&quot;docker-entry…   0B                  
&lt;missing&gt;           13 days ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B                
&lt;missing&gt;           13 days ago         /bin/sh -c apk add --no-cache --virtual .bui…   5.35MB              
&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.21.1      0B                  
&lt;missing&gt;           13 days ago         /bin/sh -c addgroup -g 1000 node     &amp;&amp; addu…   74.3MB              
&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  ENV NODE_VERSION=12.14.1     0B                  
&lt;missing&gt;           13 days ago         /bin/sh -c #(nop)  CMD [&quot;/bin/sh&quot;]              0B                  
&lt;missing&gt;           13 days ago         /bin/sh -c #(nop) ADD file:e69d441d729412d24…   5.59MB   
</code></pre></div> <p><!-- Each of the lines represents a layer in the image. The display here shows the base at the bottom with
the newest layer at the top. Using this, you can also quickly see the size of each layer, helping 
diagnose large images. --> 每一行代表镜像的一个层，底部是基础层，最新的层在顶部。使用此功能，您还可以快速查看每层的大小，以诊断大型镜像，帮助其瘦身。</p> </li> </ol> <!-- 1. You'll notice that several of the lines are truncated. If you add the `--no-trunc` flag, you'll get the
   full output (yes... funny how you use a truncated flag to get untruncated output, huh?) --> <ol> <li>您会注意到有几行被截断了。如果添加 <code>--no trunc</code> 标志，您将获得完整输出（有趣的是，您如何使用 trunc 标志来获得不受信任的输出？） <div class=highlight><pre><span></span><code>docker image <span class=nb>history</span> --no-trunc getting-started
</code></pre></div></li> </ol> <!-- ## Layer Caching --> <h2 id=layer-caching>镜像缓存（Layer Caching）<a class=headerlink href=#layer-caching title="Permanent link">&para;</a></h2> <!-- Now that you've seen the layering in action, there's an important lesson to learn to help decrease build
times for your container images. --> <p>现在您已经看到了分层的作用，有一个重要的教训要学习，以帮助减少创建容器镜像的时间。</p> <!-- > Once a layer changes, all downstream layers have to be recreated as well --> <blockquote> <p>一旦某一层改变, 所有下游层也必须重新创建</p> </blockquote> <!-- Let's look at the Dockerfile we were using one more time... --> <p>让我们再看一次我们使用的Dockerfile： <div class=highlight><pre><span></span><code><span class=k>FROM</span> <span class=s>node:12-alpine</span>
<span class=k>WORKDIR</span><span class=s> /app</span>
<span class=k>COPY</span> . .
<span class=k>RUN</span> yarn install --production
<span class=k>CMD</span> <span class=p>[</span><span class=s2>&quot;node&quot;</span><span class=p>,</span> <span class=s2>&quot;src/index.js&quot;</span><span class=p>]</span>
</code></pre></div></p> <!-- Going back to the image history output, we see that each command in the Dockerfile becomes a new layer in the image.
You might remember that when we made a change to the image, the yarn dependencies had to be reinstalled. Is there a
way to fix this? It doesn't make much sense to ship around the same dependencies every time we build, right? --> <p>回到镜像历史（image history）输出，我们看到Dockerfile中的每个命令都成为镜像中的一个新层。您可能还记得，当我们更改镜像时，必须重新安装依赖项。有没有方法能解决这个问题？我们每次构建时都要安装相同的依赖项，这没有多大意义，对吧？</p> <!-- To fix this, we need to restructure our Dockerfile to help support the caching of the dependencies. For Node-based
applications, those dependencies are defined in the `package.json` file. So, what if we copied only that file in first,
install the dependencies, and _then_ copy in everything else? Then, we only recreate the yarn dependencies if there was
a change to the `package.json`. Make sense? --> <p>为了解决这个问题，我们需要重新构造Dockerfile，以帮助支持依赖项的缓存。对node.js（Node-based applications）应用程序而言，这些依赖项定义在 <code>package.json</code> 文件中。那么，如果我们先只复制那个文件，安装依赖项，然后再复制其他内容呢？然后，我们仅需要在<code>package.json</code>改变时，再重新创建依赖项，有道理吗？</p> <!-- 1. Update the Dockerfile to copy in the `package.json` first, install dependencies, and then copy everything else in. --> <ol> <li>更新Dockerfile，首先拷贝 <code>package.json</code> , 然后安装依赖, 最后拷贝其他的一切： <div class=highlight><pre><span></span><code><span class=k>FROM</span> <span class=s>node:12-alpine</span>
<span class=k>WORKDIR</span><span class=s> /app</span>
<span class=hll><span class=c># copy</span>
</span><span class=hll><span class=k>COPY</span> package.json yarn.lock ./
</span><span class=hll><span class=c># 安装依赖</span>
</span><span class=k>RUN</span> yarn install --production
<span class=c># 拷贝余下的</span>
<span class=k>COPY</span> . .
<span class=k>CMD</span> <span class=p>[</span><span class=s2>&quot;node&quot;</span><span class=p>,</span> <span class=s2>&quot;src/index.js&quot;</span><span class=p>]</span>
</code></pre></div></li> </ol> <!-- 1. Create a file named `.dockerignore` in the same folder as the Dockerfile with the following contents. --> <ol> <li> <p>在和Dockerfile同目录下创建 <code>.dockerignore</code> 文件，写入以下内容：</p> <div class=highlight><pre><span></span><code>node_modules
</code></pre></div> <p><!-- <code>.dockerignore</code> files are an easy way to selectively copy only image relevant files.
You can read more about this
<a href="https://docs.docker.com/engine/reference/builder/#dockerignore-file">here</a>.
In this case, the <code>node_modules</code> folder should be omitted in the second <code>COPY</code> step because otherwise,
it would possibly overwrite files which were created by the command in the <code>RUN</code> step.
For further details on why this is recommended for Node.js applications and other best practices,
have a look at their guide on
<a href="https://nodejs.org/en/docs/guides/nodejs-docker-webapp/">Dockerizing a Node.js web app</a>. --> <code>.dockerignore</code>文件是一种选择性复制镜像相关文件的简单方法。您可以阅读更多关于这方面的内容 <a href=https://docs.docker.com/engine/reference/builder/#dockerignore-file>这里</a>。这样的话，在第二个<code>copy</code>命令中不会拷贝 <code>node_modules</code> 文件夹，否则，它可能会覆盖 <code>RUN</code> 命令创建的文件。有关为什么建议对node.js使用此选项的更多详细信息，请看看他们的指南 <a href=https://nodejs.org/en/docs/guides/nodejs-docker-webapp/ >Dockerizing a Node.js web app</a>。</p> </li> </ol> <!-- 1. Build a new image using `docker build`. --> <ol> <li> <p>使用<code>docker Build</code>创建新映像：</p> <div class=highlight><pre><span></span><code>docker build -t getting-started .
</code></pre></div> <p><!-- You should see output like this... --> 您会看到类似下面的输出：</p> <div class=highlight><pre><span></span><code>Sending build context to Docker daemon  219.1kB
Step 1/6 : FROM node:12-alpine
---&gt; b0dc3a5e5e9e
Step 2/6 : WORKDIR /app
---&gt; Using cache
---&gt; 9577ae713121
Step 3/6 : COPY package.json yarn.lock ./
---&gt; bd5306f49fc8
Step 4/6 : RUN yarn install --production
---&gt; Running in d53a06c9e4c2
yarn install v1.17.3
[1/4] Resolving packages...
[2/4] Fetching packages...
info fsevents@1.2.9: The platform &quot;linux&quot; is incompatible with this module.
info &quot;fsevents@1.2.9&quot; is an optional dependency and failed compatibility check. Excluding it from installation.
[3/4] Linking dependencies...
[4/4] Building fresh packages...
Done in 10.89s.
Removing intermediate container d53a06c9e4c2
---&gt; 4e68fbc2d704
Step 5/6 : COPY . .
---&gt; a239a11f68d8
Step 6/6 : CMD [&quot;node&quot;, &quot;src/index.js&quot;]
---&gt; Running in 49999f68df8f
Removing intermediate container 49999f68df8f
---&gt; e709c03bc597
Successfully built e709c03bc597
Successfully tagged getting-started:latest
</code></pre></div> <p><!-- You'll see that all layers were rebuilt. Perfectly fine since we changed the Dockerfile quite a bit. --> 您将看到所有层都已重建，非常好，因为我们对Dockerfile做了很多修改。</p> </li> </ol> <!-- 1. Now, make a change to the `src/static/index.html` file (like change the `<title>` to say "The Awesome Todo App"). --> <ol> <li>现在，对 <code>src/static/index.html</code> 进行更改（比如将<code>&lt;title&gt;</code>改为 <code>很棒的Todo应用</code>）。</li> </ol> <!-- 1. Build the Docker image now using `docker build -t getting-started .` again. This time, your output should look a little different. --> <ol> <li> <p>现在使用 <code>docker build -t getting started</code> 再创建Docker镜像一次，这次，您的输出看起来应该有点不同。</p> <div class=highlight><pre><span></span><code>Sending build context to Docker daemon  219.1kB
Step 1/6 : FROM node:12-alpine
---&gt; b0dc3a5e5e9e
Step 2/6 : WORKDIR /app
<span class=hll>---&gt; Using cache
</span>---&gt; 9577ae713121
Step 3/6 : COPY package.json yarn.lock ./
<span class=hll>---&gt; Using cache
</span>---&gt; bd5306f49fc8
Step 4/6 : RUN yarn install --production
<span class=hll>---&gt; Using cache
</span>---&gt; 4e68fbc2d704
Step 5/6 : COPY . .
---&gt; cccde25a3d9a
Step 6/6 : CMD [&quot;node&quot;, &quot;src/index.js&quot;]
---&gt; Running in 2be75662c150
Removing intermediate container 2be75662c150
---&gt; 458e5c6f080c
Successfully built 458e5c6f080c
Successfully tagged getting-started:latest
</code></pre></div> <p><!-- First off, you should notice that the build was MUCH faster! And, you'll see that steps 1-4 all have <code>Using cache</code>. So, hooray! We're using the build cache. Pushing and pulling this image and updates to it will be much faster as well. Hooray! --> 首先，您应该注意到构建速度要快得多！您也会发现步骤1-4都有<code>使用缓存</code>。所以，万岁！我们正在使用构建缓存。推拉此镜像并对其进行更新也会快得多，好极了！</p> </li> </ol> <!-- ## Multi-Stage Builds --> <h2 id=multi-stage-builds>多阶段构建（Multi-Stage Builds）<a class=headerlink href=#multi-stage-builds title="Permanent link">&para;</a></h2> <!-- While we're not going to dive into it too much in this tutorial, multi-stage builds are an incredibly powerful
tool to help use multiple stages to create an image. There are several advantages for them: --> <p>虽然在本教程中我们不会过多地深入讨论，但多阶段构建是一个非常强大的工具。该工具有助于使用多个阶段创建镜像，它们有几个优点：</p> <!-- - Separate build-time dependencies from runtime dependencies
- Reduce overall image size by shipping _only_ what your app needs to run --> <ul> <li>将构建时依赖项与运行时依赖项分开</li> <li>通过只发送应用程序运行所需的内容来减少整体镜像大小</li> </ul> <!-- ### Maven/Tomcat Example --> <h3 id=maventomcat>Maven/Tomcat 示例<a class=headerlink href=#maventomcat title="Permanent link">&para;</a></h3> <!-- When building Java-based applications, a JDK is needed to compile the source code to Java bytecode. However,
that JDK isn't needed in production. Also, you might be using tools like Maven or Gradle to help build the app.
Those also aren't needed in our final image. Multi-stage builds help. --> <p>在构建基于Java的应用程序时，需要使用JDK将源代码编译为Java字节码。然而生产中不需要JDK。此外，您可能正在使用Maven或Gradle等工具来帮助构建应用程序。在我们的最终的镜像中也不需要这些。</p> <p>以下是一个多阶段构建的示例：</p> <div class=highlight><pre><span></span><code><span class=k>FROM</span> <span class=s>maven</span> <span class=k>AS</span> <span class=s>build</span>
<span class=k>WORKDIR</span><span class=s> /app</span>
<span class=k>COPY</span> . .
<span class=k>RUN</span> mvn package

<span class=k>FROM</span> <span class=s>tomcat</span>
<span class=k>COPY</span> --from<span class=o>=</span>build /app/target/file.war /usr/local/tomcat/webapps 
</code></pre></div> <!-- In this example, we use one stage (called `build`) to perform the actual Java build using Maven. In the second
stage (starting at `FROM tomcat`), we copy in files from the `build` stage. The final image is only the last stage
being created (which can be overridden using the `--target` flag). --> <p>在本例中，我们通过第一个阶段（称为<code>build</code>）来使用Maven执行实际的Java构建。第二个阶段（从<code>FROM tomcat</code>开始），我们从<code>build</code>阶段复制文件。最终，生成的镜像只包含第一个阶段（build）创建的内容（也可以使用<code>--target</code>标志覆盖）。</p> <!-- ### React Example --> <h3 id=react>React 示例<a class=headerlink href=#react title="Permanent link">&para;</a></h3> <!-- When building React applications, we need a Node environment to compile the JS code (typically JSX), SASS stylesheets,
and more into static HTML, JS, and CSS. If we aren't doing server-side rendering, we don't even need a Node environment
for our production build. Why not ship the static resources in a static nginx container? --> <p>在构建React应用程序时，我们需要一个Node环境来编译JS代码（通常是JSX）、SASS样式表、还有更多的其他容包如静态HTML、JS和CSS等。如果我们不进行服务端渲染，生产环境中我们甚至不需要Node环境。为什么不将静态资源放在一个静态的nginx容器中？</p> <div class=highlight><pre><span></span><code><span class=k>FROM</span> <span class=s>node:12</span> <span class=k>AS</span> <span class=s>build</span>
<span class=k>WORKDIR</span><span class=s> /app</span>
<span class=k>COPY</span> package* yarn.lock ./
<span class=k>RUN</span> yarn install
<span class=k>COPY</span> public ./public
<span class=k>COPY</span> src ./src
<span class=k>RUN</span> yarn run build

<span class=k>FROM</span> <span class=s>nginx:alpine</span>
<span class=k>COPY</span> --from<span class=o>=</span>build /app/build /usr/share/nginx/html
</code></pre></div> <!-- Here, we are using a `node:12` image to perform the build (maximizing layer caching) and then copying the output
into an nginx container. Cool, huh? --> <p>在这里，我们使用一个<code>node:12</code>基础镜像来执行构建（最大化层缓存），然后复制输出文件放入nginx容器中，酷吧？</p> <h2 id=_1>总结<a class=headerlink href=#_1 title="Permanent link">&para;</a></h2> <!-- By understanding a little bit about how images are structured, we can build images faster and ship fewer changes.
Scanning images gives us confidence that the containers we are running and distributing are secure.
Multi-stage builds also help us reduce overall image size and increase final container security by separating
build-time dependencies from runtime dependencies. --> <p>通过认识理解镜像的结构，我们可以更快地构建镜像，并进行更少的更改。<br> - 扫描镜像让我们确信我们正在运行和分发的容器是安全的。 - 多阶段构建通过分离运行时依赖和编译时依赖，来帮助我们减少整体镜像大小，同时也提高了最终容器的安全性。</p> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid"> <a href=../using-docker-compose/ title="使用Docker Compose" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i> </div> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> Previous </span> 使用Docker Compose </span> </div> </a> <a href=../what-next/ title=接下来? class="md-flex md-footer-nav__link md-footer-nav__link--next" rel=next> <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"> <span class=md-flex__ellipsis> <span class=md-footer-nav__direction> Next </span> 接下来? </span> </div> <div class="md-flex__cell md-flex__cell--shrink"> <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Copyright &copy; 2020 Docker </div> powered by <a href=https://www.mkdocs.org target=_blank rel=noopener>MkDocs</a> and <a href=https://squidfunk.github.io/mkdocs-material/ target=_blank rel=noopener> Material for MkDocs</a> </div> <div class=md-footer-social> <link rel=stylesheet href=../../assets/fonts/font-awesome.css> <a href=https://github.com/xmcy0011/getting-started-cn target=_blank rel=noopener title=github-alt class="md-footer-social__link fa fa-github-alt"></a> </div> </div> </div> </footer> </div> <script src=../../assets/javascripts/application.c33a9706.js></script> <script>app.initialize({version:"1.2.3",url:{base:"../.."}})</script> </body> </html>